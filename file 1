from collections import defaultdict, deque
from typing import List, Set, Optional

class DependencyGraph:
    def __init__(self):
        self.graph = defaultdict(list)      # adjacency list: node -> [dependencies]
        self.vertices = set()

    def add_component(self, name: str):
        self.vertices.add(name)

    def add_dependency(self, from_comp: str, to_comp: str):
        self.add_component(from_comp)
        self.add_component(to_comp)
        self.graph[from_comp].append(to_comp)

    def _dfs_visit(self, node: str, visited: set, rec_stack: set, topo_order: list) -> bool:
        visited.add(node)
        rec_stack.add(node)

        for neighbor in self.graph[node]:
            if neighbor not in visited:
                if self._dfs_visit(neighbor, visited, rec_stack, topo_order):
                    return True
            elif neighbor in rec_stack:
                return True  # cycle detected

        rec_stack.remove(node)
        topo_order.append(node)
        return False

    def is_acyclic(self) -> bool:
        visited = set()
        rec_stack = set()
        topo_order = []
        for node in self.vertices:
            if node not in visited:
                if self._dfs_visit(node, visited, rec_stack, topo_order):
                    return False
        return True

    def get_topological_order(self) -> Optional[List[str]]:
        if not self.is_acyclic():
            return None
        # Re-run DFS to get order (or use Kahn's algorithm for clarity)
        visited = set()
        topo_order = []

        def dfs(node):
            visited.add(node)
            for dep in self.graph[node]:
                if dep not in visited:
                    dfs(dep)
            topo_order.append(node)

        for node in self.vertices:
            if node not in visited:
                dfs(node)

        return topo_order[::-1]  # reverse post-order = topological order
